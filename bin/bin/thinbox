#!/bin/bash

progname="thinbox"
confdir=$HOME/.$progname
sshopts="-o StrictHostKeyChecking=no -o GlobalKnownHostsFile=/dev/null "
sshopts+="-o UserKnownHostsFile=/dev/null"
[ -z "$THIN_MEMORY" ] && THIN_MEMORY="1024"

usage() {
    echo "\
Usage: $progname COMMAND [ARGS]

Manage thin VM development environments.

Commands:
    spawn NAME BASE     create new VM based on BASE image and call it NAME
    clean NAME          delete VM called NAME
    ssh NAME            ssh as root into VM called NAME
    sync NAME           rsync current git repo to VM called NAME
    upload NAME FILE    copy FILE to /root dir of VM called NAME
    list                list all VMs spawned by this tool
    base                list all available base images"
    exit 1
}

get_mac(){
    virsh domiflist $1 | sed '3q;d' | awk '{print $5}'
}

get_ipaddr() {
    local mac=$(get_mac $1)
    local line=""
    while [ -z "$line" ]; do
        line=$(arp -na | grep $mac) || sleep 0.5
    done
    line=$(echo $line | awk '{print $2}')
    echo ${line:1:-1}
}

ssh_in() {
    local ipaddr=$(get_ipaddr $1)
    ssh $sshopts root@$ipaddr
}

domain_defined() {
    virsh list --name --all | egrep -q '^'$1'$'
}

ensure_domain_defined() {
    if ! domain_defined $1; then
        echo "No VM called $1"
        exit 1
    fi
}

ensure_domain_undefined() {
    if domain_defined $1; then
        echo "VM called $1 already exists"
        exit 1
    fi
}

mkdir -p $confdir/{base,images}
cmd=$1

if [ -z "$cmd" ]; then
    usage
elif [ "$cmd" == "spawn" ]; then
    shift
    [ "$#" -ne 2 ] && usage
    name=$1
    base=$confdir/base/${2}.qcow2
    if [ ! -f "$base" ]; then
        echo "No such base image: $base"
        exit 1
    fi
    image=$confdir/images/${name}.qcow2
    ensure_domain_undefined $name

    echo "Creating new thin image"
    qemu-img create -f qcow2 -o backing_file=$base $image >/dev/null

    echo "Configuring image"
    virt-sysprep -a $image --hostname $name --ssh-inject root \
                 --firstboot-command "restorecon -R /root/.ssh" >/dev/null

    echo "Installing new VM"
    virt-install --network=bridge:virbr0 --name $name --memory $THIN_MEMORY \
                 --disk $image --import --noautoconsole >/dev/null

    echo "Waiting for IP address"
    ssh_in $name
elif [ "$cmd" == "ssh" ]; then
    shift
    [ "$#" -ne 1 ] && usage
    name=$1
    ensure_domain_defined $name
    ssh_in $name
elif [ "$cmd" == "sync" ]; then
    shift
    [ "$#" -ne 1 ] && usage
    name=$1
    ensure_domain_defined $name

    ipaddr=$(get_ipaddr $name)
    topdir=$(git rev-parse --show-toplevel) || exit 1
    remotedir=/root/$(basename $topdir)
    rsync -az -e "ssh $sshopts" --delete --exclude '.git/' $topdir/ \
          root@$ipaddr:$remotedir
elif [ "$cmd" == "upload" ]; then
    shift
    [ "$#" -ne 2 ] && usage
    name=$1
    fname=$2
    ensure_domain_defined $name

    ipaddr=$(get_ipaddr $name)
    if ! ssh root@$ipaddr stat $fname >/dev/null 2>&1; then
        scp $fname root@$ipaddr:
    else
        echo "File /root/$fname already exists on VM, aborting"
        exit 1
    fi
elif [ "$cmd" == "clean" ]; then
    shift
    [ "$#" -ne 1 ] && usage
    name=$1
    ensure_domain_defined $name

    virsh destroy $name >/dev/null 2>&1
    virsh undefine $name >/dev/null
    rm $confdir/images/${name}.qcow2
elif [ "$cmd" == "list" ]; then
    shift
    [ "$#" -ne 0 ] && usage
    for fname in $confdir/images/*; do
        [ ! -e "$fname" ] && continue
        name=$(basename $fname)
        echo ${name%.qcow2}
    done
elif [ "$cmd" == "base" ]; then
    shift
    [ "$#" -ne 0 ] && usage
    for fname in $confdir/base/*; do
        [ ! -e "$fname" ] && continue
        name=$(basename $fname)
        echo ${name%.qcow2}
    done
else
    usage
fi

exit 0
