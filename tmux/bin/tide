#!/bin/bash

PROGRAM=$(basename $0)
CMD=$1; shift
REPO=$(dirname $PWD | xargs basename)

get_conf() {
    awk -F "=" "/$1/ {print \$2}" $HOME/.config/tide/config.ini
}

set_color() {
    [ $# == 0 ] && return
    local hex=${1:1}
    local rgb=$(printf "%d;%d;%d\n" 0x${hex:0:2} 0x${hex:2:2} 0x${hex:4:2})
    printf "\x1b[38;2;${rgb}m"
}

ROOTDIR=$(get_conf rootdir)
C_DIM=$(set_color $THEME_COLOR_DIM1)
C_RES=$(printf "\x1b[0m")

cmd_usage() {
    echo "\
Usage: $PROGRAM COMMAND [ARGS]

A simple tmux(1)-based "IDE" with git-worktree(1) and toolbox(1) integration.

Commands:
    open                select worktree from menu
    status [icon|line]  generate status bar (to use from ~/.tmux.conf)
"
    exit 1
}

list_worktrees() {
    local repo name
    if [ $# == 0 ]; then
        repo=$PWD
        name=
    else
        repo=$1
        name="  ${repo##$ROOTDIR/}"
    fi
    git -C $repo worktree list --porcelain | \
    while read label path; read label obj; read label ref; read; do
        path=${path##$ROOTDIR/}
        ref=${ref##*/}
        printf "${path}${C_DIM} 󰘬 ${ref:-HEAD}  ${obj:0:10}${name}${C_RES}\n"
    done
}

list_repos() {
    find "$ROOTDIR" -maxdepth 4 -name .git -type d -printf '%h\n' | sort | \
    while read path; do
        list_worktrees $path
    done
}

press_key() {
    echo
    echo -n "Press ENTER to continue"
    read
    clear
    [ "$1" == "-n" ] || exit 1
}

confirm() {
    local prompt=$1; shift
    read -p "${prompt} [y/N]? " -n1 -r
    clear
    if [ "$REPLY" = "y" ]; then
        "$@"
        return $?
    fi
}

open() {
    local path=$1
    local name=$2
    if ! tmux has-session -t="$name" 2>/dev/null; then
        tmux new-session -ds "$name" -n " Code" \
                         "sleep 0.1; while true; do $EDITOR -c GFiles; done"
        tmux new-window -t "$name" -n "󰘬 Git" "sleep 0.1; while true; do TIG_SCRIPT=<(echo :enter) tig; done"
        tmux new-window -t "$name" -n " Build"
        tmux select-window -t "${name}:+1"
        tmux set @repo $(echo "${path%%/*}")
        tmux set @path $(echo "${path#*/}")
    fi

    if [ -z "$TMUX" ]; then
        tmux attach -t "$name"
    else
        tmux switch-client -t "$name"
    fi
}

cmd_open() {
    local line path name

    line=$(list_worktrees | \
    fzf --prompt "  " --ansi -n1,3 \
        --ghost "Open a worktree" \
    )

    [ -z "$line" ] && return
    path=$(echo "$line" | awk '{print $1}')
    name=$(echo "$path" | sed 's/\./-/g')
    cd "$ROOTDIR/$path"

    open $path $name
}

cmd_open_all () {
    local line path name

    line=$(list_repos | \
    fzf --prompt "  " --ansi -n1,3 \
        --ghost "Open a global worktree" \
    )

    [ -z "$line" ] && return
    path=$(echo "$line" | awk '{print $1}')
    name=$(echo "$path" | sed 's/\./-/g')
    cd "$ROOTDIR/$path"

    open $path $name
}

list_branches() {
    format=(
        "%(if:equals=tag)%(objecttype)%(then)%(else)󰘬%(end)"
        "%(refname:lstrip=-1)"
        "%(creatordate:relative)"
    )
    git for-each-ref --sort '-creatordate' --format="${format[*]}" \
        | grep -v HEAD | awk '!seen[$2]++' | \
    while read symbol name date; do
        printf "${symbol} ${name} ${C_DIM}${date}${C_RES}\n"
    done
}

cmd_checkout() {
    local line ref

    line=$(list_branches | \
    fzf --prompt "  " --ansi -n2,4 \
        --ghost "Checkout a branch or tag" \
    )

    [ -z "$line" ] && return
    ref=$(echo "$line" | awk '{print $2}')

    git checkout $ref || press_key
    git ctags
    tmux refresh-client
}

cmd_worktree_add() {
    local line ref

    line=$(list_branches | \
    fzf --prompt "  " --ansi -n2,4 \
        --ghost "Add a worktree for a branch or tag" \
    )

    [ -z "$line" ] && return
    ref=$(echo "$line" | awk '{print $2}')

    [ -d ../$ref ] && return
    git worktree add ../$ref || press_key
}

cmd_worktree_rm() {
    local hint ghost_loc ghost_all line path name

    line=$(list_worktrees | \
    fzf --prompt "  " --ansi -n1,3 \
        --ghost "Remove a worktree" \
    )

    [ -z "$line" ] && return
    path=$(echo "$line" | awk '{print $1}')
    name=$(echo "$path" | sed 's/\./-/g')
    confirm "Remove worktree $ROOTDIR/$path" \
    git worktree remove "$ROOTDIR/$path" || press_key
}

list_pr() {
    if [ "$1" == "--all" ]; then
        query=
    else
        query="user-review-requested:@me"
    fi
    template=(
        '{{range .}}{{.number}} {{.author.login}} '
        '{{.headRefName}} {{.title}}{{"\n"}}{{end}}'
    )
    gh pr list --search "$query" \
               --json number,title,author,headRefName \
               --template "${template[*]}" | \
    while read number author ref title; do
        printf "${C_DIM}#%s${C_RES} %s ${C_DIM} %s 󰘬 %s${C_RES}\n" \
               "$number" "$title" "$author" "$ref"
    done
}

cmd_checkout_gh() {
    local line ref
    line=$(list_pr | \
    fzf --prompt "  " --ansi \
        --ghost "Checkout an assigned Pull Request" \
    )

    [ -z "$line" ] && return
    ref=$(echo "$line" | awk '{print $1}')

    gh pr checkout $ref || press_key
    git ctags
    tmux refresh-client
}

cmd_checkout_gh_all() {
    local line ref
    line=$(list_pr --all | \
    fzf --prompt "  " --ansi \
        --ghost "Checkout a Pull Request" \
    )

    [ -z "$line" ] && return
    ref=$(echo "$line" | awk '{print $1}')

    gh pr checkout $ref || press_key
    git ctags
    tmux refresh-client
}

cmd_clone() {
    local forge line repo
    forge=$1

    line=$(cat ~/.config/tide/${forge}.txt | \
    fzf --prompt "  " --ansi \
        --ghost "Clone a repo with $forge" \
    )

    [ -z "$line" ] && return
    path=$ROOTDIR/$line/$forge/main
    [ -d "$path" ] && return
    mkdir -p $path

    $forge clone $line $path
}

cmd_clone_fedora() { cmd_clone fedpkg; }
cmd_clone_redhat() { cmd_clone rhpkg; }

cmd_reload() {
    case $1 in
        --all)
            list_repos
        ;;
        --pr)
            list_pr
        ;;
        --pr-all)
            list_pr --all
        ;;
        *)
            list_worktrees
        ;;
    esac
}

cmd_status() {
    local cmd=$1
    local pane_command=$2
    shift

    print_branch() {
        git -C $1 rev-parse --is-inside-work-tree >/dev/null || return 0
        printf "󰘬 $(git -C $1 rev-parse --abbrev-ref HEAD)"
    }

    print_toolbox() {
        [ "$pane_command" == "toolbox" ] || return 0
        printf "󰆧 toolbx  "
    }

    case $cmd in
        left)
            print_branch "$@"
        ;;
        right)
            print_toolbox "$@"
        ;;
    esac
}

cmd_refresh() {
    tmux source-file ~/.tmux.conf
    tmux display-message "  Config reloaded"
}

cmd_git_status() {
    local num=$(git diff --staged --stat --diff-filter=u | wc -l)
    [ $num == 0 ] && num=2
    num=$(( num + 2 ))
    TIG_SCRIPT=<(echo -e ":${num}\n:enter") tig status
}

list_commits() {
    git log --date=relative \
            --format="${C_DIM}%h${C_RES} %s ${C_DIM} %aL %cd${C_RES}"
}

cmd_git_find() {
    line=$(list_commits | \
    fzf --prompt "  " --ansi -n2.. --no-hscroll \
        --ghost "Find a commit" \
    )
    [ -z "$line" ] && return
    ref=$(echo "$line" | awk '{print $1}')
    full=$(git rev-parse $ref)
    tmux new-window -n " $ref" \
        bash -c "TIG_SCRIPT=<(echo -e ':$full\n:enter') tig"
}

cmd_palette() {
    local cmds menu list text cmd
    declare -A menu

    cmds=(
        cmd_open        	"Git Worktree: Open"
        cmd_open_all        	"Git Worktree: Open Global"
        cmd_worktree_add        "Git Worktree: Add"
        cmd_worktree_rm         "Git Worktree: Remove"
        cmd_clone_fedora    	"Git Clone: Fedora"
        cmd_clone_redhat    	"Git Clone: RHEL"
        cmd_checkout		"Git Checkout"
        cmd_git_find    	"Git Log: Find Commit"
        cmd_checkout_gh		"GitHub Pull Request: Checkout"
        cmd_checkout_gh_all     "GitHub Pull Request: Checkout Global"
    )

    list=()
    for ((i = 0; i < ${#cmds[@]}; i += 2)); do
        text=${cmds[i + 1]}
        menu[$text]=${cmds[i]}
        list+=("$text")
    done

    cmd=$(printf "%s\n" "${list[@]}" | \
    fzf --prompt "  " \
        --ghost "Perform an action" \
        --bind 'alt-w:close' \
    )

    [ -z "$cmd" ] && return
    ${menu[$cmd]}
}

case $CMD in
    open)               cmd_open "$@" ;;
    reload)             cmd_reload "$@" ;;
    status)             cmd_status "$@" ;;
    git-status)         cmd_git_status "$@" ;;
    palette)            cmd_palette "$@" ;;
    refresh)            cmd_refresh "$@" ;;
    *)                  cmd_usage ;;
esac
