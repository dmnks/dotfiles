#!/bin/bash

PROGRAM=$(basename $0)
CMD=$1; shift
REPO=$(dirname $PWD | xargs basename)

source ~/.theme/bashrc

get_conf() {
    awk -F "=" "/$1/ {print \$2}" $HOME/.config/tide/config.ini
}

set_color() {
    [ $# == 0 ] && return
    local hex=${1:1}
    local rgb=$(printf "%d;%d;%d\n" 0x${hex:0:2} 0x${hex:2:2} 0x${hex:4:2})
    printf "\x1b[38;2;${rgb}m"
}

ROOTDIR=$(get_conf rootdir)
C_DIM=$(set_color $THEME_COLOR_DIM1)
C_RES=$(printf "\x1b[0m")

cmd_usage() {
    echo "\
Usage: $PROGRAM COMMAND [ARGS]

A simple tmux(1)-based "IDE" with git-worktree(1) and toolbox(1) integration.

Commands:
    open                select worktree from menu
    status [icon|line]  generate status bar (to use from ~/.tmux.conf)
"
    exit 1
}

list_worktrees() {
    local repo name
    if [ $# == 0 ]; then
        repo=$PWD
        name=
    else
        repo=$1
        name="  ${repo##$ROOTDIR/}"
    fi
    git -C $repo worktree list --porcelain | \
    while read label path; read label obj; read label ref; read; do
        path=${path##$ROOTDIR/}
        ref=${ref##*/}
        printf "${path}${C_DIM} 󰘬 ${ref:-HEAD}  ${obj:0:10}${name}${C_RES}\n"
    done
}

list_repos() {
    find "$ROOTDIR" -maxdepth 4 -name .git -type d -printf '%h\n' | sort | \
    while read path; do
        list_worktrees $path
    done
}

press_key() {
    echo
    echo -n "Press ENTER to continue"
    read
    clear
    [ "$1" == "-n" ] || exit 1
}

confirm() {
    local prompt=$1; shift
    read -p "${prompt} [y/N]? " -n1 -r
    clear
    if [ "$REPLY" = "y" ]; then
        "$@"
        return $?
    fi
}

cmd_open() {
    local hint ghost_loc ghost_all line path name
    hint="press CTRL-G to show"
    ghost_loc="Switch to a worktree ($hint global)"
    ghost_all="Switch to a worktree ($hint local)"

    line=$(list_worktrees | \
    fzf --prompt "  " --ansi -n1,3 \
        --ghost "$ghost_loc" \
        --bind "ctrl-g:transform:[[ \$FZF_GHOST == '$ghost_loc' ]] &&
                echo 'change-ghost($ghost_all)+reload(tide reload --all)' ||
                echo 'change-ghost($ghost_loc)+reload(tide reload)'" \
    )

    [ -z "$line" ] && return
    path=$(echo "$line" | awk '{print $1}')
    name=$(echo "$path" | sed 's/\./-/g')
    cd "$ROOTDIR/$path"

    if ! tmux has-session -t="$name" 2>/dev/null; then
        tmux new-session -ds "$name" -n " Code" \
                         "sleep 0.1; while true; do $EDITOR -c GFiles; done"
        tmux new-window -t "$name" -n "󰘬 Git" "sleep 0.1; while true; do TIG_SCRIPT=<(echo :enter) tig; done"
        tmux new-window -t "$name" -n " Build"
        tmux select-window -t "${name}:+1"
        tmux set @repo $(echo "${path%%/*}")
        tmux set @path $(echo "${path#*/}")
    fi

    if [ -z "$TMUX" ]; then
        tmux attach -t "$name"
    else
        tmux switch-client -t "$name"
    fi
}

list_branches() {
    format=(
        "%(if:equals=tag)%(objecttype)%(then)%(else)󰘬%(end)"
        "%(refname:short)"
        "%(if)%(upstream)%(then)%(upstream:short)%(else)none%(end)"
        "%(objectname:short=10)"
    )
    git for-each-ref --format="${format[*]}" refs/{heads,tags} | \
    while read symbol name upstream object; do
        [ $name == HEAD ] && continue
        [ "$upstream" == "none" ] && upstream= || upstream=" $upstream "
        printf "${symbol} ${name} ${C_DIM}${upstream} ${object}${C_RES}\n"
    done
}

cmd_checkout() {
    local line ref

    line=$(list_branches | \
    fzf --prompt "  " --ansi -n2,4 \
        --ghost "Checkout a branch or tag" \
    )

    [ -z "$line" ] && return
    ref=$(echo "$line" | awk '{print $2}')
    upstream=$(echo "$line" | awk '{print $4}')

    if ! git rev-parse --verify $ref 2>&1 >/dev/null; then
        git branch $ref $upstream || press_key
    fi
    git checkout $ref || press_key
    git ctags
    tmux refresh-client
}

cmd_worktree_add() {
    local line ref

    line=$(list_branches | \
    fzf --prompt "  " --ansi -n2,4 \
        --ghost "Create a worktree for a branch or tag" \
    )

    [ -z "$line" ] && return
    ref=$(echo "$line" | awk '{print $2}')

    [ -d ../$ref ] && return
    git worktree add ../$ref || press_key
}

cmd_worktree_rm() {
    local hint ghost_loc ghost_all line path name

    line=$(list_worktrees | \
    fzf --prompt "  " --ansi -n1,3 \
        --ghost "Remove a worktree" \
    )

    [ -z "$line" ] && return
    path=$(echo "$line" | awk '{print $1}')
    name=$(echo "$path" | sed 's/\./-/g')
    confirm "Remove worktree $ROOTDIR/$path" \
    git worktree remove "$ROOTDIR/$path" || press_key
}

list_pr() {
    if [ "$1" == "--all" ]; then
        query=
    else
        query="user-review-requested:@me"
    fi
    template=(
        '{{range .}}{{.number}} {{.author.login}} '
        '{{.headRefName}} {{.title}}{{"\n"}}{{end}}'
    )
    gh pr list --search "$query" \
               --json number,title,author,headRefName \
               --template "${template[*]}" | \
    while read number author ref title; do
        printf "${C_DIM}#%s${C_RES} %s ${C_DIM} %s 󰘬 %s${C_RES}\n" \
               "$number" "$title" "$author" "$ref"
    done
}

cmd_checkout_gh() {
    local line ref
    hint="press CTRL-G to show"
    ghost_loc="Checkout a GitHub Pull Request ($hint all)"
    ghost_all="Checkout a GitHub Pull Request ($hint assigned)"
    line=$(list_pr | \
    fzf --prompt "  " --ansi \
        --ghost "$ghost_loc" \
        --bind "ctrl-g:transform:[[ \$FZF_GHOST == '$ghost_loc' ]] &&
                echo 'change-ghost($ghost_all)+reload(tide reload --pr-all)' ||
                echo 'change-ghost($ghost_loc)+reload(tide reload --pr)'" \
    )

    [ -z "$line" ] && return
    ref=$(echo "$line" | awk '{print $1}')

    gh pr checkout $ref || press_key
    git ctags
    tmux refresh-client
}

cmd_clone() {
    local forge line repo
    forge=$1

    line=$(cat ~/.config/tide/${forge}.txt | \
    fzf --prompt "  " --ansi \
        --ghost "Clone a repo with $forge" \
    )

    [ -z "$line" ] && return
    path=$ROOTDIR/$line/$forge/main
    [ -d "$path" ] && return
    mkdir -p $path

    $forge clone $line $path
}

cmd_clone_fedora() { cmd_clone fedpkg; }
cmd_clone_redhat() { cmd_clone rhpkg; }

cmd_reload() {
    case $1 in
        --all)
            list_repos
        ;;
        --pr)
            list_pr
        ;;
        --pr-all)
            list_pr --all
        ;;
        *)
            list_worktrees
        ;;
    esac
}

cmd_status() {
    local cmd=$1
    shift

    print_branch() {
        git -C $1 rev-parse --is-inside-work-tree >/dev/null || return 0
        printf "󰘬 $(git -C $1 rev-parse --abbrev-ref HEAD)"
    }

    case $cmd in
        left)
            print_branch "$@"
        ;;
    esac
}

cmd_refresh() {
    for var in ACCENT_COLOR; do
        tmux set-environment    $var "${!var}"
        tmux set-environment -g $var "${!var}"
    done
    tmux source-file ~/.tmux.conf
    tmux display-message "  Config reloaded"
}

cmd_git_status() {
    local num=$(git diff --staged --stat | wc -l)
    [ $num == 0 ] && num=2
    num=$(( num + 2 ))
    TIG_SCRIPT=<(echo -e ":${num}\n:enter") tig status
}

cmd_theme() {
    set-theme
}

cmd_palette() {
    local cmds menu list text cmd
    declare -A menu

    cmds=(
        cmd_open        	"Worktree: Switch"
        cmd_worktree_add        "Worktree: Create"
        cmd_worktree_rm         "Worktree: Remove"
        cmd_checkout		"Git: Checkout"
        cmd_clone_fedora    	"Git: Clone Fedora Repo"
        cmd_clone_redhat    	"Git: Clone RHEL Repo"
        cmd_checkout_gh		"GitHub: Checkout Pull Request"
        cmd_theme       	"Settings: Set Theme"
    )

    list=()
    for ((i = 0; i < ${#cmds[@]}; i += 2)); do
        text=${cmds[i + 1]}
        menu[$text]=${cmds[i]}
        list+=("$text")
    done

    cmd=$(printf "%s\n" "${list[@]}" | \
    fzf --prompt "  " \
        --ghost "Choose a command to run" \
        --bind 'alt-w:close' \
    )

    [ -z "$cmd" ] && return
    ${menu[$cmd]}
}

case $CMD in
    open)               cmd_open "$@" ;;
    reload)             cmd_reload "$@" ;;
    status)             cmd_status "$@" ;;
    git-status)         cmd_git_status "$@" ;;
    palette)            cmd_palette "$@" ;;
    refresh)            cmd_refresh "$@" ;;
    *)                  cmd_usage ;;
esac
